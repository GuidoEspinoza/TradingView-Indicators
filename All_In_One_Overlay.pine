//@version=6
indicator("Smart Trading Bot - All-In-One (100% Synced)", shorttitle="Bot Suite", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// ==========================================
// ðŸ¤– 100% SYNCHRONIZED WITH SMART TRADING BOT
// ==========================================
// This indicator replicates the EXACT logic of the Python bot
// including: ADX adaptive thresholds, optimal hours, avoid windows,
// confluence scoring, and all filters.
// Last sync: 2026-01-29

// ==========================================
// 1. AUTO MULTI-CONFLUENCE SIGNAL
// ==========================================
group_conf = "=== Multi-Confluence Signals ==="
// Divergence
rsiLength = input.int(14, "RSI Length", group=group_conf)
macdFast = input.int(12, "MACD Fast", group=group_conf)
macdSlow = input.int(26, "MACD Slow", group=group_conf)
macdSignal = input.int(9, "MACD Signal", group=group_conf)
pivotLookback = input.int(5, "Pivot Lookback", group=group_conf)

// Trend Settings (UPDATED TO MATCH BOT 'Intraday-Trend')
trendMA1 = input.int(20, "Fast MA (Trend)", group=group_conf) // Sync with Bot (20)
trendMA2 = input.int(100, "Slow MA (Trend)", group=group_conf) // Sync with Bot (100)
maType = input.string("EMA", "MA Type", options=["SMA", "EMA"], group=group_conf)
atrLen = input.int(14, "ATR Length", group=group_conf)

// ADX Settings (Adaptive - Sync with Bot)
adxLen = input.int(14, "ADX Smoothing", group=group_conf)
diLen = input.int(14, "DI Length", group=group_conf)
// ADX Threshold is now ADAPTIVE (see below)

// ==========================================
// ðŸ• BOT FILTERS: OPTIMAL HOURS & AVOID WINDOWS
// ==========================================
group_bot_filters = "=== ðŸ¤– Bot Filters (Critical) ==="
enableOptimalHours = input.bool(true, "âœ… Enable Optimal Hours Filter", group=group_bot_filters, tooltip="Bot only trades during optimal liquidity windows per symbol")
symbolType = input.string("AUTO", "Symbol Type", 
    options=["AUTO", "GOLD", "SILVER", "OIL_CRUDE", "EURUSD", "GBPUSD", "USDJPY", "AUDUSD", "USDCHF", "EURJPY", "GBPJPY", 
             "US30", "US100", "US500", "UK100", "FR40", "DE40", "J225", "HK50", 
             "BTCUSD", "ETHUSD", "XRPUSD", "SOLUSD"], 
    group=group_bot_filters,
    tooltip="Select symbol type or AUTO to detect from chart")

enableAvoidWindows = input.bool(true, "âœ… Enable Avoid Windows Filter", group=group_bot_filters, tooltip="Bot avoids high manipulation periods (London/NY open, Tokyo, Rollover)")

// Auto-detect symbol type from chart ticker
detectedSymbol = str.contains(syminfo.ticker, "GOLD") or str.contains(syminfo.ticker, "XAU") ? "GOLD" : str.contains(syminfo.ticker, "SILVER") or str.contains(syminfo.ticker, "XAG") ? "SILVER" : str.contains(syminfo.ticker, "OIL") or str.contains(syminfo.ticker, "CL") or str.contains(syminfo.ticker, "WTI") ? "OIL_CRUDE" : str.contains(syminfo.ticker, "EURUSD") ? "EURUSD" : str.contains(syminfo.ticker, "GBPUSD") ? "GBPUSD" : str.contains(syminfo.ticker, "USDJPY") ? "USDJPY" : str.contains(syminfo.ticker, "AUDUSD") ? "AUDUSD" : str.contains(syminfo.ticker, "USDCHF") ? "USDCHF" : str.contains(syminfo.ticker, "EURJPY") ? "EURJPY" : str.contains(syminfo.ticker, "GBPJPY") ? "GBPJPY" : str.contains(syminfo.ticker, "US30") or str.contains(syminfo.ticker, "DJI") or str.contains(syminfo.ticker, "YM") ? "US30" : str.contains(syminfo.ticker, "US100") or str.contains(syminfo.ticker, "NAS100") or str.contains(syminfo.ticker, "NQ") ? "US100" : str.contains(syminfo.ticker, "US500") or str.contains(syminfo.ticker, "SPX500") or str.contains(syminfo.ticker, "ES") ? "US500" : str.contains(syminfo.ticker, "UK100") or str.contains(syminfo.ticker, "FTSE") ? "UK100" : str.contains(syminfo.ticker, "FR40") or str.contains(syminfo.ticker, "CAC") ? "FR40" : str.contains(syminfo.ticker, "DE40") or str.contains(syminfo.ticker, "DAX") or str.contains(syminfo.ticker, "GER") ? "DE40" : str.contains(syminfo.ticker, "J225") or str.contains(syminfo.ticker, "NKY") or str.contains(syminfo.ticker, "NIKKEI") ? "J225" : str.contains(syminfo.ticker, "HK50") or str.contains(syminfo.ticker, "HSI") ? "HK50" : str.contains(syminfo.ticker, "BTC") ? "BTCUSD" : str.contains(syminfo.ticker, "ETH") ? "ETHUSD" : str.contains(syminfo.ticker, "XRP") ? "XRPUSD" : str.contains(syminfo.ticker, "SOL") ? "SOLUSD" : "GOLD"

activeSymbol = symbolType == "AUTO" ? detectedSymbol : symbolType

// Optimal Hours Logic (Exact sync with symbols_config.py)
currentHour = hour(time, "UTC")
currentMinute = minute(time, "UTC")

isOptimalHour = not enableOptimalHours or (
    (activeSymbol == "GOLD" and currentHour >= 1 and currentHour < 20) or
    (activeSymbol == "SILVER" and currentHour >= 7 and currentHour < 19) or
    (activeSymbol == "OIL_CRUDE" and ((currentHour >= 13 and currentHour < 19) or (currentHour >= 8 and currentHour < 11))) or
    (activeSymbol == "EURUSD" and currentHour >= 7 and currentHour < 16) or
    (activeSymbol == "GBPUSD" and currentHour >= 7 and currentHour < 17) or
    (activeSymbol == "USDJPY" and ((currentHour >= 0 and currentHour < 9) or (currentHour >= 13 and currentHour < 19))) or
    (activeSymbol == "AUDUSD" and ((currentHour >= 0 and currentHour < 8) or (currentHour >= 13 and currentHour < 17))) or
    (activeSymbol == "USDCHF" and currentHour >= 7 and currentHour < 16) or
    (activeSymbol == "EURJPY" and ((currentHour >= 0 and currentHour < 9) or (currentHour >= 12 and currentHour < 16))) or
    (activeSymbol == "GBPJPY" and ((currentHour >= 7 and currentHour < 16) or (currentHour >= 0 and currentHour < 4))) or
    (activeSymbol == "US30" and currentHour >= 13 and currentHour < 22) or
    (activeSymbol == "US100" and currentHour >= 13 and currentHour < 22) or
    (activeSymbol == "US500" and currentHour >= 13 and currentHour < 22) or
    (activeSymbol == "UK100" and currentHour >= 8 and currentHour < 17) or
    (activeSymbol == "FR40" and currentHour >= 7 and currentHour < 16) or
    (activeSymbol == "DE40" and currentHour >= 7 and currentHour < 16) or
    (activeSymbol == "J225" and currentHour >= 0 and currentHour < 6) or
    (activeSymbol == "HK50" and ((currentHour >= 1 and currentHour < 4) or (currentHour >= 5 and currentHour < 8))) or
    (activeSymbol == "BTCUSD" and currentHour >= 7 and currentHour < 21) or
    (activeSymbol == "ETHUSD" and currentHour >= 7 and currentHour < 21) or
    (activeSymbol == "XRPUSD" and currentHour >= 7 and currentHour < 21) or
    (activeSymbol == "SOLUSD" and currentHour >= 7 and currentHour < 21)
)

// Avoid Windows Logic (Exact sync with core_config.py)
isAvoidWindow = enableAvoidWindows and (
    // London Open: 07:30-09:00 UTC
    (currentHour == 7 and currentMinute >= 30) or (currentHour == 8 and currentMinute < 60) or
    // NY Open: 13:30-15:00 UTC
    (currentHour == 13 and currentMinute >= 30) or (currentHour == 14 and currentMinute < 60) or
    // Tokyo Open: 00:00-01:30 UTC
    (currentHour == 0 and currentMinute < 90) or
    // Rollover: 21:50-23:10 UTC
    (currentHour == 21 and currentMinute >= 50) or (currentHour == 22) or (currentHour == 23 and currentMinute < 10)
)

// ADX Adaptive Threshold (Exact sync with profiles.py)
isLondonNY = currentHour >= 7 and currentHour < 20
isAsia = currentHour >= 0 and currentHour < 7
adxThresholdAdaptive = isLondonNY ? 25 : isAsia ? 18 : 20

// Momentum & Volume (UPDATED TO MATCH BOT)
momentumLength = input.int(14, "Momentum Period", group=group_conf)
volumeMA = input.int(50, "Volume MA Length", group=group_conf) // Sync with Bot (50)

// Ichimoku
conversionPeriods = input.int(9, "Conversion Line", group=group_conf)
basePeriods = input.int(26, "Base Line", group=group_conf)
laggingSpan2Periods = input.int(52, "Leading Span B", group=group_conf)
displacement = input.int(26, "Displacement", group=group_conf)

// Signal Logic
confluenceRequired = input.int(5, "Min Confluence (Bot=5)", minval=1, maxval=9, group=group_conf, tooltip="Bot requires 5/9 conditions. DO NOT change unless you modify bot's CONFLUENCE_THRESHOLD.")
signalMaxAge = input.int(3, "Max Bars Since Base", minval=1, group=group_conf)
showDivergence = input.bool(true, "Show Divergence", group=group_conf)
showSignals = input.bool(true, "Show Buy/Sell Signals", group=group_conf)
showMacdCrossAlerts = input.bool(true, "Show MACD Cross Alerts", group=group_conf)
showTrendShift = input.bool(true, "Show Trend Shifts", group=group_conf)
showTable = input.bool(true, "Show Info Table", group=group_conf)

group_weights = "=== Scoring Weights (Sync with Bot: All 1) ==="
wTrend = input.int(1, "Trend Weight", group=group_weights, minval=0) // Sync with Bot (Equal weight 1)
wMomentum = input.int(1, "Momentum Weight", group=group_weights, minval=0)
wStructure = input.int(1, "Structure Weight", group=group_weights, minval=0)
wVolume = input.int(1, "Volume Weight", group=group_weights, minval=0)
wIchimoku = input.int(1, "Ichimoku Weight", group=group_weights, minval=0)
wMacd = input.int(1, "MACD Weight", group=group_weights, minval=0)

group_filter = "=== MTF Trend Filter ==="
useTrendFilter = input.bool(true, "Enable Trend Filter", group=group_filter)
filterTf_input = input.string("Auto", "Filter Timeframe", options=["Auto", "1", "3", "5", "15", "30", "60", "240", "D"], group=group_filter)

// Determinar el timeframe del filtro real. Si es "Auto", se ajusta dinÃ¡micamente.
string filterTf = if filterTf_input == "Auto"
    timeframe.isintraday and timeframe.multiplier <= 5 ? "60" : "240" // Adjusted: H1 filter for M15, H4 for H1
else
    filterTf_input

// Timeframe Logic
useCurrentRes = input.bool(true, "Use Current Chart Resolution?", group=group_conf)
resCustom = input.string("60", "Use Different Timeframe", options=["1","5","15","30","60","240"], group=group_conf)
useAutoParams = input.bool(false, "Auto-Adjust Params", group=group_conf) // Sync with Bot (False)

tf = useCurrentRes ? timeframe.period : resCustom
tfSec = timeframe.in_seconds(tf)
is1 = tfSec == 60
is3 = tfSec == 180
is5 = tfSec == 300
is15 = tfSec == 900
is30 = tfSec == 1800
is60 = tfSec == 3600
is240 = tfSec == 14400
lowTF = is1 or is3 or is5

// Effective Params (Still useful if Auto is enabled, but defaults match Bot now)
rsiLenEff = useAutoParams ? (is1 ? 8 : is3 ? 10 : is5 ? 12 : is15 ? 14 : is30 ? 14 : is60 ? 14 : is240 ? 14 : rsiLength) : rsiLength
macdFastEff = useAutoParams ? (is1 ? 6 : is3 ? 7 : is5 ? 8 : is15 ? 12 : is30 ? 12 : is60 ? 12 : is240 ? 12 : macdFast) : macdFast
macdSlowEff = useAutoParams ? (is1 ? 13 : is3 ? 17 : is5 ? 20 : is15 ? 26 : is30 ? 26 : is60 ? 26 : is240 ? 26 : macdSlow) : macdSlow
macdSignalEff = useAutoParams ? (is1 ? 4 : is3 ? 5 : is5 ? 6 : is15 ? 9 : is30 ? 9 : is60 ? 9 : is240 ? 9 : macdSignal) : macdSignal
trendMA1Eff = useAutoParams ? (is1 ? 9 : is3 ? 12 : is5 ? 18 : is15 ? 20 : is30 ? 20 : is60 ? 20 : is240 ? 50 : trendMA1) : trendMA1
trendMA2Eff = useAutoParams ? (is1 ? 24 : is3 ? 30 : is5 ? 50 : is15 ? 100 : is30 ? 100 : is60 ? 100 : is240 ? 200 : trendMA2) : trendMA2
momentumLengthEff = useAutoParams ? (is1 ? 7 : is3 ? 9 : is5 ? 12 : is15 ? 14 : is30 ? 20 : is60 ? 20 : is240 ? 21 : momentumLength) : momentumLength
volumeMAEff = useAutoParams ? (is1 ? 32 : is3 ? 35 : is5 ? 40 : is15 ? 50 : is30 ? 60 : is60 ? 50 : is240 ? 100 : volumeMA) : volumeMA
confluenceEff = lowTF ? (is1 ? 2 : is3 ? 3 : is5 ? 3 : 3) : confluenceRequired
signalMaxAgeEff = lowTF ? (is1 ? 3 : is3 ? 3 : is5 ? 3 : 2) : signalMaxAge

// Ichimoku Effective Params
conversionEff = useAutoParams ? (is1 ? 5 : is3 ? 9 : is5 ? 9 : is15 ? 9 : is30 ? 12 : is60 ? 9 : is240 ? 9 : conversionPeriods) : conversionPeriods
baseEff = useAutoParams ? (is1 ? 10 : is3 ? 26 : is5 ? 20 : is15 ? 26 : is30 ? 30 : is60 ? 26 : is240 ? 26 : basePeriods) : basePeriods
leadingSpanBEff = useAutoParams ? (is1 ? 20 : is3 ? 52 : is5 ? 40 : is15 ? 52 : is30 ? 60 : is60 ? 52 : is240 ? 52 : laggingSpan2Periods) : laggingSpan2Periods

// Data Fetching (Anti-Repainting)
srcO = request.security(syminfo.tickerid, tf, open, barmerge.gaps_off, barmerge.lookahead_off)
srcH = request.security(syminfo.tickerid, tf, high, barmerge.gaps_off, barmerge.lookahead_off)
srcL = request.security(syminfo.tickerid, tf, low, barmerge.gaps_off, barmerge.lookahead_off)
srcC = request.security(syminfo.tickerid, tf, close, barmerge.gaps_off, barmerge.lookahead_off)
srcV = request.security(syminfo.tickerid, tf, volume, barmerge.gaps_off, barmerge.lookahead_off)
atrValue = request.security(syminfo.tickerid, tf, ta.atr(atrLen), barmerge.gaps_off, barmerge.lookahead_off)
ma1 = maType == "EMA" ? ta.ema(srcC, trendMA1Eff) : ta.sma(srcC, trendMA1Eff)
ma2 = maType == "EMA" ? ta.ema(srcC, trendMA2Eff) : ta.sma(srcC, trendMA2Eff)

// Indicators Calc
rsi = ta.rsi(srcC, rsiLenEff)
[macdLine, signalLine, macdHist] = ta.macd(srcC, macdFastEff, macdSlowEff, macdSignalEff)
momentum = ta.mom(srcC, momentumLengthEff)
volMA = ta.sma(srcV, volumeMAEff)
volumeStrength = srcV > volMA
trendStrength = math.abs(ma1 - ma2) / atrValue

// ADX Calc (with adaptive threshold)
[diplus, diminus, adx] = ta.dmi(diLen, adxLen)
adxFilter = adx > adxThresholdAdaptive  // Uses adaptive threshold (18/20/25 based on session)

// MTF Trend Filter Logic
filterClose = request.security(syminfo.tickerid, filterTf, srcC, barmerge.gaps_off, barmerge.lookahead_off)
filterMA = request.security(syminfo.tickerid, filterTf, ma2, barmerge.gaps_off, barmerge.lookahead_off)
mainTrendUp = filterClose > filterMA

// Ichimoku
donchian(len) => math.avg(ta.lowest(srcL, len), ta.highest(srcH, len))
conversionLine = donchian(conversionEff)
baseLine = donchian(baseEff)
leadSpanA = math.avg(conversionLine, baseLine)
leadSpanB = donchian(leadingSpanBEff)

// Divergence Logic (V2.1 - Fixed Types)
pivoth_val_price = ta.pivothigh(srcH, pivotLookback, pivotLookback)
pivotl_val_price = ta.pivotlow(srcL, pivotLookback, pivotLookback)

// Create boolean series for pivot occurrences
bool pivoth_detected = not na(pivoth_val_price)
bool pivotl_detected = not na(pivotl_val_price)

// Bearish Divergence: Higher High in Price, Lower High in RSI
// Get price and RSI at the current pivot high
float ph_price = ta.valuewhen(pivoth_detected, srcH[pivotLookback], 0)
float ph_rsi = ta.valuewhen(pivoth_detected, rsi[pivotLookback], 0)
// Get price and RSI at the previous pivot high
float ph_price_prev = ta.valuewhen(pivoth_detected, srcH[pivotLookback], 1)
float ph_rsi_prev = ta.valuewhen(pivoth_detected, rsi[pivotLookback], 1)

bearishDiv = pivoth_detected and (ph_price > ph_price_prev) and (ph_rsi < ph_rsi_prev)

// Bullish Divergence: Lower Low in Price, Higher Low in RSI
// Get price and RSI at the current pivot low
float pl_price = ta.valuewhen(pivotl_detected, srcL[pivotLookback], 0)
float pl_rsi = ta.valuewhen(pivotl_detected, rsi[pivotLookback], 0)
// Get price and RSI at the previous pivot low
float pl_price_prev = ta.valuewhen(pivotl_detected, srcL[pivotLookback], 1)
float pl_rsi_prev = ta.valuewhen(pivotl_detected, rsi[pivotLookback], 1)

bullishDiv = pivotl_detected and (pl_price < pl_price_prev) and (pl_rsi > pl_rsi_prev)

// Trend & Conditions
macroTrendBullish = ma2 > ta.ema(ma2, 100)
currentTrendBullish = srcC > ma1 and ma1 > ma2
bullishTrendShift = ta.crossover(ma1, ma2)
bearishTrendShift = ta.crossunder(ma1, ma2)
momentumBullish = momentum > 0 and momentum > momentum[1]
structureBullish = high > high[5] and low > low[5]
overbought = rsi > 70
oversold = rsi < 30
volumeBullish = srcV > volMA and srcC > srcO

// Scoring (Weighted)
bullishScore = 0
bullishScore += currentTrendBullish ? wTrend : 0
bullishScore += momentumBullish ? wMomentum : 0
bullishScore += structureBullish ? wStructure : 0
bullishScore += volumeBullish ? wVolume : 0
bullishScore += (srcC > leadSpanA and srcC > leadSpanB) ? wIchimoku : 0
bullishScore += macdHist > 0 ? wMacd : 0

bearishScore = 0
bearishScore += not currentTrendBullish ? wTrend : 0
bearishScore += not momentumBullish ? wMomentum : 0
bearishScore += not structureBullish ? wStructure : 0
bearishScore += not volumeBullish ? wVolume : 0
bearishScore += (srcC < leadSpanA and srcC < leadSpanB) ? wIchimoku : 0
bearishScore += macdHist < 0 ? wMacd : 0

// MACD Cross Events
macdBullishCross = ta.crossover(macdLine, signalLine)
macdBearishCross = ta.crossunder(macdLine, signalLine)

// Signals
rsiCrossOver30 = ta.crossover(rsi, 30)
rsiCrossUnder70 = ta.crossunder(rsi, 70)
var int lastBullBaseBar = na
var int lastBearBaseBar = na
if bullishDiv or bullishTrendShift or (oversold and rsiCrossOver30)
    lastBullBaseBar := bar_index
if bearishDiv or bearishTrendShift or (overbought and rsiCrossUnder70)
    lastBearBaseBar := bar_index
freshBull = not na(lastBullBaseBar) and (bar_index - lastBullBaseBar) <= signalMaxAgeEff
freshBear = not na(lastBearBaseBar) and (bar_index - lastBearBaseBar) <= signalMaxAgeEff

strongBull = bullishTrendShift and macdHist > 0 and momentumBullish
strongBear = bearishTrendShift and macdHist < 0 and not momentumBullish

buySignal = bullishDiv and bullishScore >= confluenceEff
buySignal := buySignal or (bullishTrendShift and bullishScore >= confluenceEff)
buySignal := buySignal or (strongBull and bullishScore >= (confluenceEff - 1))
buySignal := buySignal or (oversold and rsiCrossOver30 and bullishScore >= confluenceEff)
buySignal := buySignal and freshBull
buySignal := buySignal and (is1 and not strongBull ? (currentTrendBullish and momentumBullish) : true)
buySignal := buySignal and (lowTF and not strongBull ? macdHist > 0 : true)

sellSignal = bearishDiv and bearishScore >= confluenceEff
sellSignal := sellSignal or (bearishTrendShift and bearishScore >= confluenceEff)
sellSignal := sellSignal or (strongBear and bearishScore >= (confluenceEff - 1))
sellSignal := sellSignal or (overbought and rsiCrossUnder70 and bearishScore >= confluenceEff)
sellSignal := sellSignal and freshBear
sellSignal := sellSignal and (is1 and not strongBear ? (not currentTrendBullish and not momentumBullish) : true)
sellSignal := sellSignal and (lowTF and not strongBear ? macdHist < 0 : true)
sellSignal := sellSignal and (not useTrendFilter or not mainTrendUp)

// Global Filters Application (ADX + Optimal Hours + Avoid Windows)
buySignal := buySignal and adxFilter and isOptimalHour and not isAvoidWindow
sellSignal := sellSignal and adxFilter and isOptimalHour and not isAvoidWindow

// Plots
plot(ma1, "Fast MA", color=color.new(color.blue, 0), linewidth=1)
plot(ma2, "Slow MA", color=color.new(color.orange, 0), linewidth=2)

// Signal Plots (as arrows)
plotshape(showSignals and buySignal, "Buy Alert", shape.triangleup, location.belowbar, color.new(color.blue, 0), size=size.tiny)
plotshape(showSignals and sellSignal, "Sell Alert", shape.triangledown, location.abovebar, color.new(color.blue, 0), size=size.tiny)

// MACD Cross Plots (as diamonds)
plotshape(showMacdCrossAlerts and macdBullishCross, "MACD Bull Cross", shape.diamond, location.belowbar, color.new(color.yellow, 0), size=size.tiny)
plotshape(showMacdCrossAlerts and macdBearishCross, "MACD Bear Cross", shape.diamond, location.abovebar, color.new(color.yellow, 0), size=size.tiny)

if showTable
    var table indicatorTable = table.new(position.top_right, 2, 9, border_width=1)
    
    // === BOT STATUS SECTION ===
    // Bot Ready (All filters passed)
    botReady = isOptimalHour and not isAvoidWindow and adxFilter
    table.cell(indicatorTable, 0, 0, "ðŸ¤– BOT READY", bgcolor=color.new(color.gray, 0), text_color=color.white, text_size=size.normal)
    table.cell(indicatorTable, 1, 0, botReady ? "âœ… YES" : "âŒ NO", 
        bgcolor=botReady ? color.new(color.green, 0) : color.new(color.red, 0), 
        text_color=color.white, text_size=size.normal)
    
    // Optimal Hours Status
    table.cell(indicatorTable, 0, 1, "â° Optimal Hours", bgcolor=color.gray, text_color=color.white)
    table.cell(indicatorTable, 1, 1, isOptimalHour ? "âœ…" : "âŒ OUT", 
        bgcolor=isOptimalHour ? color.green : color.red, text_color=color.white)
    
    // Avoid Window Status
    table.cell(indicatorTable, 0, 2, "ðŸš« Avoid Window", bgcolor=color.gray, text_color=color.white)
    table.cell(indicatorTable, 1, 2, isAvoidWindow ? "âš ï¸ YES" : "âœ… NO", 
        bgcolor=isAvoidWindow ? color.red : color.green, text_color=color.white)
    
    // ADX Threshold (Adaptive)
    table.cell(indicatorTable, 0, 3, "ADX Req/Actual", bgcolor=color.gray, text_color=color.white)
    adxStatus = str.tostring(adxThresholdAdaptive) + "/" + str.tostring(math.round(adx, 1))
    table.cell(indicatorTable, 1, 3, adxStatus, 
        bgcolor=adx > adxThresholdAdaptive ? color.green : color.red, text_color=color.white)
    
    // === MARKET ANALYSIS SECTION ===
    // Main Trend Filter
    table.cell(indicatorTable, 0, 4, "Filtro " + filterTf, bgcolor=color.gray, text_color=color.white)
    table.cell(indicatorTable, 1, 4, useTrendFilter ? (mainTrendUp ? "â–²" : "â–¼") : "â€”", 
        bgcolor=useTrendFilter ? (mainTrendUp ? color.green : color.red) : color.gray, text_color=color.white)
    
    // Current TF Trend
    table.cell(indicatorTable, 0, 5, "Tendencia " + tf, bgcolor=color.gray, text_color=color.white)
    table.cell(indicatorTable, 1, 5, currentTrendBullish ? "â–²" : "â–¼", 
        bgcolor=currentTrendBullish ? color.green : color.red, text_color=color.white)
    
    // Momentum
    table.cell(indicatorTable, 0, 6, "Momentum", bgcolor=color.gray, text_color=color.white)
    table.cell(indicatorTable, 1, 6, momentumBullish ? "â–²" : "â–¼", 
        bgcolor=momentumBullish ? color.green : color.red, text_color=color.white)
    
    // Volume
    table.cell(indicatorTable, 0, 7, "Volume", bgcolor=color.gray, text_color=color.white)
    table.cell(indicatorTable, 1, 7, volumeStrength ? "High" : "Low", 
        bgcolor=volumeStrength ? color.green : color.red, text_color=color.white)
    
    // Confluence Score
    table.cell(indicatorTable, 0, 8, "Confluence", bgcolor=color.gray, text_color=color.white)
    confluenceStatus = str.tostring(bullishScore) + "/" + str.tostring(bearishScore)
    table.cell(indicatorTable, 1, 8, confluenceStatus, 
        bgcolor=bullishScore >= confluenceRequired ? color.green : (bearishScore >= confluenceRequired ? color.red : color.gray), 
        text_color=color.white)

// ==========================================
// 2. ATR TRAILING STOP
// ==========================================
group_atr = "=== ATR Trailing Stop ==="
atrMult = input.float(2.5, "ATR Multiplier", step=0.1, group=group_atr) // Sync with Bot (2.5)
showAtrLabels = input.bool(true, "Show Stop Labels", group=group_atr)

stopDist = atrValue * atrMult
var float longStop = na
var float shortStop = na
var int dir = 1

longStopCandidate = srcC - stopDist
shortStopCandidate = srcC + stopDist

longStop := if (srcC > longStop[1])
    math.max(longStopCandidate, nz(longStop[1]))
else
    longStopCandidate

shortStop := if (srcC < shortStop[1])
    math.min(shortStopCandidate, nz(shortStop[1]))
else
    shortStopCandidate

if (srcC > nz(shortStop[1]) and dir == -1)
    dir := 1
else if (srcC < nz(longStop[1]) and dir == 1)
    dir := -1

activeStop = dir == 1 ? longStop : shortStop
stopColor = dir == 1 ? color.new(color.green, 0) : color.new(color.red, 0)
plot(activeStop, "Trailing Stop", color=stopColor, linewidth=2, style=plot.style_linebr)

var label priceLabel = na
if showAtrLabels and barstate.islast
    label.delete(priceLabel)
    priceLabel := label.new(x=bar_index + 1, y=activeStop, text="SL: " + str.tostring(math.round_to_mintick(activeStop)), color=stopColor, textcolor=color.white, style=label.style_label_left, size=size.small)

// ==========================================
// 3. INSTITUTIONAL VWAP
// ==========================================
group_vwap = "=== Institutional VWAP ==="
showVwapBands = input.bool(true, "Show VWAP Bands", group=group_vwap)
stdevMultVwap = input.float(1.5, "VWAP Stdev", step=0.1, group=group_vwap)

startPeriod = timeframe.change("D")
var float sumSrcVol = 0.0
var float sumVol = 0.0
var float sumSrcSrcVol = 0.0

if startPeriod
    sumSrcVol := 0.0
    sumVol := 0.0
    sumSrcSrcVol := 0.0

sumSrcVol += hlc3 * volume
sumVol += volume
sumSrcSrcVol += volume * math.pow(hlc3, 2)

vwapValue = sumSrcVol / sumVol
variance = sumSrcSrcVol / sumVol - math.pow(vwapValue, 2)
stdev = math.sqrt(math.max(variance, 0))
upperBand = vwapValue + stdev * stdevMultVwap
lowerBand = vwapValue - stdev * stdevMultVwap

vwapTrend = close > vwapValue ? 1 : -1
vwapColor = vwapTrend == 1 ? color.new(color.green, 0) : color.new(color.red, 0)

plot(vwapValue, "VWAP", color=vwapColor, linewidth=1)
p1 = plot(showVwapBands ? upperBand : na, "VWAP Upper", color=color.new(color.gray, 80))
p2 = plot(showVwapBands ? lowerBand : na, "VWAP Lower", color=color.new(color.gray, 80))
fill(p1, p2, color=color.new(vwapColor, 95))

// ==========================================
// 4. AUTO ORDER BLOCKS
// ==========================================
group_ob = "=== Auto Order Blocks ==="
obLookback = input.int(2, "OB Pivot Lookback (Bot=2)", minval=1, group=group_ob, tooltip="Bot uses 2 (Bill Williams standard). DO NOT change unless you modify bot's fractal_n.")
obTransp = input.int(85, "OB Transparency", minval=0, maxval=100, group=group_ob)

ph = ta.pivothigh(high, obLookback, obLookback)
pl = ta.pivotlow(low, obLookback, obLookback)

var box[] bullBoxes = array.new_box()
var box[] bearBoxes = array.new_box()

// Clean Bull Boxes
if array.size(bullBoxes) > 0
    for i = array.size(bullBoxes) - 1 to 0
        b = array.get(bullBoxes, i)
        if close < box.get_bottom(b)
            box.delete(b)
            array.remove(bullBoxes, i)

// Clean Bear Boxes
if array.size(bearBoxes) > 0
    for i = array.size(bearBoxes) - 1 to 0
        b = array.get(bearBoxes, i)
        if close > box.get_top(b)
            box.delete(b)
            array.remove(bearBoxes, i)

// New Bull OB
if not na(pl)
    b = box.new(left=bar_index - obLookback, top=high[obLookback], bottom=low[obLookback], right=bar_index + 50, 
         bgcolor=color.new(color.green, obTransp), border_color=color.new(color.green, 80))
    array.push(bullBoxes, b)

// New Bear OB
if not na(ph)
    b = box.new(left=bar_index - obLookback, top=high[obLookback], bottom=low[obLookback], right=bar_index + 50, 
         bgcolor=color.new(color.red, obTransp), border_color=color.new(color.red, 80))
    array.push(bearBoxes, b)

// Extend
if array.size(bullBoxes) > 0
    if array.size(bullBoxes) > 10
        box.delete(array.shift(bullBoxes))
    for i = 0 to array.size(bullBoxes) - 1
        box.set_right(array.get(bullBoxes, i), bar_index + 10)

if array.size(bearBoxes) > 0
    if array.size(bearBoxes) > 10
        box.delete(array.shift(bearBoxes))
    for i = 0 to array.size(bearBoxes) - 1
        box.set_right(array.get(bearBoxes, i), bar_index + 10)
