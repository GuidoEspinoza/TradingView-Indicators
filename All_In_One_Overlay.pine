//@version=6
indicator("Professional All-In-One Overlay", shorttitle="Pro Suite", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// ==========================================
// 1. AUTO MULTI-CONFLUENCE SIGNAL
// ==========================================
group_conf = "=== Multi-Confluence Signals ==="
// Divergence
rsiLength = input.int(14, "RSI Length", group=group_conf)
macdFast = input.int(12, "MACD Fast", group=group_conf)
macdSlow = input.int(26, "MACD Slow", group=group_conf)
macdSignal = input.int(9, "MACD Signal", group=group_conf)
pivotLookback = input.int(5, "Pivot Lookback", group=group_conf)

// Trend Settings
trendMA1 = input.int(9, "Fast MA", group=group_conf) // Sync with Bot (9)
trendMA2 = input.int(21, "Slow MA (Trend)", group=group_conf) // Sync with Bot (21)
maType = input.string("EMA", "MA Type", options=["SMA", "EMA"], group=group_conf)
atrLen = input.int(14, "ATR Length", group=group_conf)

// ADX Settings (New for Bot Sync)
adxLen = input.int(14, "ADX Smoothing", group=group_conf)
diLen = input.int(14, "DI Length", group=group_conf)
adxThreshold = input.int(20, "Min ADX Strength", group=group_conf)

// Momentum & Volume
momentumLength = input.int(14, "Momentum Period", group=group_conf)
volumeMA = input.int(20, "Volume MA Length", group=group_conf)

// Ichimoku
conversionPeriods = input.int(9, "Conversion Line", group=group_conf)
basePeriods = input.int(26, "Base Line", group=group_conf)
laggingSpan2Periods = input.int(52, "Leading Span B", group=group_conf)
displacement = input.int(26, "Displacement", group=group_conf)

// Signal Logic
confluenceRequired = input.int(4, "Min Confluence", minval=1, maxval=6, group=group_conf) // Sync with Bot (4)
signalMaxAge = input.int(3, "Max Bars Since Base", minval=1, group=group_conf)
showDivergence = input.bool(true, "Show Divergence", group=group_conf)
showSignals = input.bool(true, "Show Buy/Sell Signals", group=group_conf)
showMacdCrossAlerts = input.bool(true, "Show MACD Cross Alerts", group=group_conf)
showTrendShift = input.bool(true, "Show Trend Shifts", group=group_conf)
showTable = input.bool(true, "Show Info Table", group=group_conf)

group_weights = "=== Scoring Weights ==="
wTrend = input.int(2, "Trend Weight", group=group_weights, minval=0)
wMomentum = input.int(1, "Momentum Weight", group=group_weights, minval=0)
wStructure = input.int(1, "Structure Weight", group=group_weights, minval=0)
wVolume = input.int(1, "Volume Weight", group=group_weights, minval=0)
wIchimoku = input.int(1, "Ichimoku Weight", group=group_weights, minval=0)
wMacd = input.int(1, "MACD Weight", group=group_weights, minval=0)

group_filter = "=== MTF Trend Filter ==="
useTrendFilter = input.bool(true, "Enable Trend Filter", group=group_filter)
filterTf_input = input.string("Auto", "Filter Timeframe", options=["Auto", "1", "3", "5", "15", "30", "60", "240", "D"], group=group_filter)

// Determinar el timeframe del filtro real. Si es "Auto", se ajusta dinámicamente.
string filterTf = if filterTf_input == "Auto"
    timeframe.isintraday and timeframe.multiplier <= 5 ? "5" : "60"
else
    filterTf_input

// Timeframe Logic
useCurrentRes = input.bool(true, "Use Current Chart Resolution?", group=group_conf)
resCustom = input.string("60", "Use Different Timeframe", options=["1","5","15","30","60","240"], group=group_conf)
useAutoParams = input.bool(false, "Auto-Adjust Params", group=group_conf) // Sync with Bot (False)

tf = useCurrentRes ? timeframe.period : resCustom
tfSec = timeframe.in_seconds(tf)
is1 = tfSec == 60
is3 = tfSec == 180
is5 = tfSec == 300
is15 = tfSec == 900
is30 = tfSec == 1800
is60 = tfSec == 3600
is240 = tfSec == 14400
lowTF = is1 or is3 or is5

// Effective Params
rsiLenEff = useAutoParams ? (is1 ? 8 : is3 ? 10 : is5 ? 12 : is15 ? 14 : is30 ? 14 : is60 ? 14 : is240 ? 14 : rsiLength) : rsiLength
macdFastEff = useAutoParams ? (is1 ? 6 : is3 ? 7 : is5 ? 8 : is15 ? 12 : is30 ? 12 : is60 ? 12 : is240 ? 12 : macdFast) : macdFast
macdSlowEff = useAutoParams ? (is1 ? 13 : is3 ? 17 : is5 ? 20 : is15 ? 26 : is30 ? 26 : is60 ? 26 : is240 ? 26 : macdSlow) : macdSlow
macdSignalEff = useAutoParams ? (is1 ? 4 : is3 ? 5 : is5 ? 6 : is15 ? 9 : is30 ? 9 : is60 ? 9 : is240 ? 9 : macdSignal) : macdSignal
trendMA1Eff = useAutoParams ? (is1 ? 9 : is3 ? 12 : is5 ? 18 : is15 ? 20 : is30 ? 20 : is60 ? 50 : is240 ? 50 : trendMA1) : trendMA1
trendMA2Eff = useAutoParams ? (is1 ? 24 : is3 ? 30 : is5 ? 50 : is15 ? 100 : is30 ? 100 : is60 ? 200 : is240 ? 200 : trendMA2) : trendMA2
momentumLengthEff = useAutoParams ? (is1 ? 7 : is3 ? 9 : is5 ? 12 : is15 ? 14 : is30 ? 20 : is60 ? 20 : is240 ? 21 : momentumLength) : momentumLength
volumeMAEff = useAutoParams ? (is1 ? 32 : is3 ? 35 : is5 ? 40 : is15 ? 50 : is30 ? 60 : is60 ? 70 : is240 ? 100 : volumeMA) : volumeMA
confluenceEff = lowTF ? (is1 ? 2 : is3 ? 3 : is5 ? 3 : 3) : confluenceRequired
signalMaxAgeEff = lowTF ? (is1 ? 3 : is3 ? 3 : is5 ? 3 : 2) : signalMaxAge

// Ichimoku Effective Params
conversionEff = useAutoParams ? (is1 ? 5 : is3 ? 9 : is5 ? 9 : is15 ? 9 : is30 ? 12 : is60 ? 9 : is240 ? 9 : conversionPeriods) : conversionPeriods
baseEff = useAutoParams ? (is1 ? 10 : is3 ? 26 : is5 ? 20 : is15 ? 26 : is30 ? 30 : is60 ? 26 : is240 ? 26 : basePeriods) : basePeriods
leadingSpanBEff = useAutoParams ? (is1 ? 20 : is3 ? 52 : is5 ? 40 : is15 ? 52 : is30 ? 60 : is60 ? 52 : is240 ? 52 : laggingSpan2Periods) : laggingSpan2Periods

// Data Fetching (Anti-Repainting)
srcO = request.security(syminfo.tickerid, tf, open, barmerge.gaps_off, barmerge.lookahead_off)
srcH = request.security(syminfo.tickerid, tf, high, barmerge.gaps_off, barmerge.lookahead_off)
srcL = request.security(syminfo.tickerid, tf, low, barmerge.gaps_off, barmerge.lookahead_off)
srcC = request.security(syminfo.tickerid, tf, close, barmerge.gaps_off, barmerge.lookahead_off)
srcV = request.security(syminfo.tickerid, tf, volume, barmerge.gaps_off, barmerge.lookahead_off)
atrValue = request.security(syminfo.tickerid, tf, ta.atr(atrLen), barmerge.gaps_off, barmerge.lookahead_off)
ma1 = maType == "EMA" ? ta.ema(srcC, trendMA1Eff) : ta.sma(srcC, trendMA1Eff)
ma2 = maType == "EMA" ? ta.ema(srcC, trendMA2Eff) : ta.sma(srcC, trendMA2Eff)

// Indicators Calc
rsi = ta.rsi(srcC, rsiLenEff)
[macdLine, signalLine, macdHist] = ta.macd(srcC, macdFastEff, macdSlowEff, macdSignalEff)
momentum = ta.mom(srcC, momentumLengthEff)
volMA = ta.sma(srcV, volumeMAEff)
volumeStrength = srcV > volMA
trendStrength = math.abs(ma1 - ma2) / atrValue

// ADX Calc
[diplus, diminus, adx] = ta.dmi(diLen, adxLen)
adxFilter = adx > adxThreshold

// MTF Trend Filter Logic
filterClose = request.security(syminfo.tickerid, filterTf, srcC, barmerge.gaps_off, barmerge.lookahead_off)
filterMA = request.security(syminfo.tickerid, filterTf, ma2, barmerge.gaps_off, barmerge.lookahead_off)
mainTrendUp = filterClose > filterMA

// Ichimoku
donchian(len) => math.avg(ta.lowest(srcL, len), ta.highest(srcH, len))
conversionLine = donchian(conversionEff)
baseLine = donchian(baseEff)
leadSpanA = math.avg(conversionLine, baseLine)
leadSpanB = donchian(leadingSpanBEff)

// Divergence Logic (V2.1 - Fixed Types)
pivoth_val_price = ta.pivothigh(srcH, pivotLookback, pivotLookback)
pivotl_val_price = ta.pivotlow(srcL, pivotLookback, pivotLookback)

// Create boolean series for pivot occurrences
bool pivoth_detected = not na(pivoth_val_price)
bool pivotl_detected = not na(pivotl_val_price)

// Bearish Divergence: Higher High in Price, Lower High in RSI
// Get price and RSI at the current pivot high
float ph_price = ta.valuewhen(pivoth_detected, srcH[pivotLookback], 0)
float ph_rsi = ta.valuewhen(pivoth_detected, rsi[pivotLookback], 0)
// Get price and RSI at the previous pivot high
float ph_price_prev = ta.valuewhen(pivoth_detected, srcH[pivotLookback], 1)
float ph_rsi_prev = ta.valuewhen(pivoth_detected, rsi[pivotLookback], 1)

bearishDiv = pivoth_detected and (ph_price > ph_price_prev) and (ph_rsi < ph_rsi_prev)

// Bullish Divergence: Lower Low in Price, Higher Low in RSI
// Get price and RSI at the current pivot low
float pl_price = ta.valuewhen(pivotl_detected, srcL[pivotLookback], 0)
float pl_rsi = ta.valuewhen(pivotl_detected, rsi[pivotLookback], 0)
// Get price and RSI at the previous pivot low
float pl_price_prev = ta.valuewhen(pivotl_detected, srcL[pivotLookback], 1)
float pl_rsi_prev = ta.valuewhen(pivotl_detected, rsi[pivotLookback], 1)

bullishDiv = pivotl_detected and (pl_price < pl_price_prev) and (pl_rsi > pl_rsi_prev)

// Trend & Conditions
macroTrendBullish = ma2 > ta.ema(ma2, 100)
currentTrendBullish = srcC > ma1 and ma1 > ma2
bullishTrendShift = ta.crossover(ma1, ma2)
bearishTrendShift = ta.crossunder(ma1, ma2)
momentumBullish = momentum > 0 and momentum > momentum[1]
structureBullish = high > high[5] and low > low[5]
overbought = rsi > 70
oversold = rsi < 30
volumeBullish = srcV > volMA and srcC > srcO

// Scoring (Weighted)
bullishScore = 0
bullishScore += currentTrendBullish ? wTrend : 0
bullishScore += momentumBullish ? wMomentum : 0
bullishScore += structureBullish ? wStructure : 0
bullishScore += volumeBullish ? wVolume : 0
bullishScore += (srcC > leadSpanA and srcC > leadSpanB) ? wIchimoku : 0
bullishScore += macdHist > 0 ? wMacd : 0

bearishScore = 0
bearishScore += not currentTrendBullish ? wTrend : 0
bearishScore += not momentumBullish ? wMomentum : 0
bearishScore += not structureBullish ? wStructure : 0
bearishScore += not volumeBullish ? wVolume : 0
bearishScore += (srcC < leadSpanA and srcC < leadSpanB) ? wIchimoku : 0
bearishScore += macdHist < 0 ? wMacd : 0

// MACD Cross Events
macdBullishCross = ta.crossover(macdLine, signalLine)
macdBearishCross = ta.crossunder(macdLine, signalLine)

// Signals
rsiCrossOver30 = ta.crossover(rsi, 30)
rsiCrossUnder70 = ta.crossunder(rsi, 70)
var int lastBullBaseBar = na
var int lastBearBaseBar = na
if bullishDiv or bullishTrendShift or (oversold and rsiCrossOver30)
    lastBullBaseBar := bar_index
if bearishDiv or bearishTrendShift or (overbought and rsiCrossUnder70)
    lastBearBaseBar := bar_index
freshBull = not na(lastBullBaseBar) and (bar_index - lastBullBaseBar) <= signalMaxAgeEff
freshBear = not na(lastBearBaseBar) and (bar_index - lastBearBaseBar) <= signalMaxAgeEff

strongBull = bullishTrendShift and macdHist > 0 and momentumBullish
strongBear = bearishTrendShift and macdHist < 0 and not momentumBullish

buySignal = bullishDiv and bullishScore >= confluenceEff
buySignal := buySignal or (bullishTrendShift and bullishScore >= confluenceEff)
buySignal := buySignal or (strongBull and bullishScore >= (confluenceEff - 1))
buySignal := buySignal or (oversold and rsiCrossOver30 and bullishScore >= confluenceEff)
buySignal := buySignal and freshBull
buySignal := buySignal and (is1 and not strongBull ? (currentTrendBullish and momentumBullish) : true)
buySignal := buySignal and (lowTF and not strongBull ? macdHist > 0 : true)

sellSignal = bearishDiv and bearishScore >= confluenceEff
sellSignal := sellSignal or (bearishTrendShift and bearishScore >= confluenceEff)
sellSignal := sellSignal or (strongBear and bearishScore >= (confluenceEff - 1))
sellSignal := sellSignal or (overbought and rsiCrossUnder70 and bearishScore >= confluenceEff)
sellSignal := sellSignal and freshBear
sellSignal := sellSignal and (is1 and not strongBear ? (not currentTrendBullish and not momentumBullish) : true)
sellSignal := sellSignal and (lowTF and not strongBear ? macdHist < 0 : true)
sellSignal := sellSignal and (not useTrendFilter or not mainTrendUp)

// Global ADX Filter Application
buySignal := buySignal and adxFilter
sellSignal := sellSignal and adxFilter

// Plots
plot(ma1, "Fast MA", color=color.new(color.blue, 0), linewidth=1)
plot(ma2, "Slow MA", color=color.new(color.orange, 0), linewidth=2)

// Signal Plots (as arrows)
plotshape(showSignals and buySignal, "Buy Alert", shape.triangleup, location.belowbar, color.new(color.blue, 0), size=size.tiny)
plotshape(showSignals and sellSignal, "Sell Alert", shape.triangledown, location.abovebar, color.new(color.blue, 0), size=size.tiny)

// MACD Cross Plots (as diamonds)
plotshape(showMacdCrossAlerts and macdBullishCross, "MACD Bull Cross", shape.diamond, location.belowbar, color.new(color.yellow, 0), size=size.tiny)
plotshape(showMacdCrossAlerts and macdBearishCross, "MACD Bear Cross", shape.diamond, location.abovebar, color.new(color.yellow, 0), size=size.tiny)

if showTable
    var table indicatorTable = table.new(position.top_right, 2, 5, border_width=1)
    // Main Trend Filter
    table.cell(indicatorTable, 0, 0, "Filtro " + filterTf, bgcolor=color.gray, text_color=color.white)
    table.cell(indicatorTable, 1, 0, useTrendFilter ? (mainTrendUp ? "▲" : "▼") : "—", bgcolor=useTrendFilter ? (mainTrendUp ? color.green : color.red) : color.gray, text_color=color.white)
    // Current TF Indicators
    table.cell(indicatorTable, 0, 1, "Tendencia " + tf, bgcolor=color.gray, text_color=color.white)
    table.cell(indicatorTable, 1, 1, currentTrendBullish ? "▲" : "▼", bgcolor=currentTrendBullish ? color.green : color.red, text_color=color.white)
    table.cell(indicatorTable, 0, 2, "Mom", bgcolor=color.gray, text_color=color.white)
    table.cell(indicatorTable, 1, 2, momentumBullish ? "▲" : "▼", bgcolor=momentumBullish ? color.green : color.red, text_color=color.white)
    table.cell(indicatorTable, 0, 3, "Vol", bgcolor=color.gray, text_color=color.white)
    table.cell(indicatorTable, 1, 3, volumeStrength ? "High" : "Low", bgcolor=volumeStrength ? color.green : color.red, text_color=color.white)

// ==========================================
// 2. ATR TRAILING STOP
// ==========================================
group_atr = "=== ATR Trailing Stop ==="
atrMult = input.float(2.5, "ATR Multiplier", step=0.1, group=group_atr) // Sync with Bot (2.5)
showAtrLabels = input.bool(true, "Show Stop Labels", group=group_atr)

stopDist = atrValue * atrMult
var float longStop = na
var float shortStop = na
var int dir = 1

longStopCandidate = srcC - stopDist
shortStopCandidate = srcC + stopDist

longStop := if (srcC > longStop[1])
    math.max(longStopCandidate, nz(longStop[1]))
else
    longStopCandidate

shortStop := if (srcC < shortStop[1])
    math.min(shortStopCandidate, nz(shortStop[1]))
else
    shortStopCandidate

if (srcC > nz(shortStop[1]) and dir == -1)
    dir := 1
else if (srcC < nz(longStop[1]) and dir == 1)
    dir := -1

activeStop = dir == 1 ? longStop : shortStop
stopColor = dir == 1 ? color.new(color.green, 0) : color.new(color.red, 0)
plot(activeStop, "Trailing Stop", color=stopColor, linewidth=2, style=plot.style_linebr)

var label priceLabel = na
if showAtrLabels and barstate.islast
    label.delete(priceLabel)
    priceLabel := label.new(x=bar_index + 1, y=activeStop, text="SL: " + str.tostring(math.round_to_mintick(activeStop)), color=stopColor, textcolor=color.white, style=label.style_label_left, size=size.small)

// ==========================================
// 3. INSTITUTIONAL VWAP
// ==========================================
group_vwap = "=== Institutional VWAP ==="
showVwapBands = input.bool(true, "Show VWAP Bands", group=group_vwap)
stdevMultVwap = input.float(1.5, "VWAP Stdev", step=0.1, group=group_vwap)

startPeriod = timeframe.change("D")
var float sumSrcVol = 0.0
var float sumVol = 0.0
var float sumSrcSrcVol = 0.0

if startPeriod
    sumSrcVol := 0.0
    sumVol := 0.0
    sumSrcSrcVol := 0.0

sumSrcVol += hlc3 * volume
sumVol += volume
sumSrcSrcVol += volume * math.pow(hlc3, 2)

vwapValue = sumSrcVol / sumVol
variance = sumSrcSrcVol / sumVol - math.pow(vwapValue, 2)
stdev = math.sqrt(math.max(variance, 0))
upperBand = vwapValue + stdev * stdevMultVwap
lowerBand = vwapValue - stdev * stdevMultVwap

vwapTrend = close > vwapValue ? 1 : -1
vwapColor = vwapTrend == 1 ? color.new(color.green, 0) : color.new(color.red, 0)

plot(vwapValue, "VWAP", color=vwapColor, linewidth=1)
p1 = plot(showVwapBands ? upperBand : na, "VWAP Upper", color=color.new(color.gray, 80))
p2 = plot(showVwapBands ? lowerBand : na, "VWAP Lower", color=color.new(color.gray, 80))
fill(p1, p2, color=color.new(vwapColor, 95))

// ==========================================
// 4. AUTO ORDER BLOCKS
// ==========================================
group_ob = "=== Auto Order Blocks ==="
obLookback = input.int(5, "OB Pivot Lookback", minval=1, group=group_ob)
obTransp = input.int(85, "OB Transparency", minval=0, maxval=100, group=group_ob)

ph = ta.pivothigh(high, obLookback, obLookback)
pl = ta.pivotlow(low, obLookback, obLookback)

var box[] bullBoxes = array.new_box()
var box[] bearBoxes = array.new_box()

// Clean Bull Boxes
if array.size(bullBoxes) > 0
    for i = array.size(bullBoxes) - 1 to 0
        b = array.get(bullBoxes, i)
        if close < box.get_bottom(b)
            box.delete(b)
            array.remove(bullBoxes, i)

// Clean Bear Boxes
if array.size(bearBoxes) > 0
    for i = array.size(bearBoxes) - 1 to 0
        b = array.get(bearBoxes, i)
        if close > box.get_top(b)
            box.delete(b)
            array.remove(bearBoxes, i)

// New Bull OB
if not na(pl)
    b = box.new(left=bar_index - obLookback, top=high[obLookback], bottom=low[obLookback], right=bar_index + 50, 
         bgcolor=color.new(color.green, obTransp), border_color=color.new(color.green, 80))
    array.push(bullBoxes, b)

// New Bear OB
if not na(ph)
    b = box.new(left=bar_index - obLookback, top=high[obLookback], bottom=low[obLookback], right=bar_index + 50, 
         bgcolor=color.new(color.red, obTransp), border_color=color.new(color.red, 80))
    array.push(bearBoxes, b)

// Extend
if array.size(bullBoxes) > 0
    if array.size(bullBoxes) > 10
        box.delete(array.shift(bullBoxes))
    for i = 0 to array.size(bullBoxes) - 1
        box.set_right(array.get(bullBoxes, i), bar_index + 10)

if array.size(bearBoxes) > 0
    if array.size(bearBoxes) > 10
        box.delete(array.shift(bearBoxes))
    for i = 0 to array.size(bearBoxes) - 1
        box.set_right(array.get(bearBoxes, i), bar_index + 10)
